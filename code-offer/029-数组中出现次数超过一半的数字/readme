[toc]

## 题目
- [题目](https://blog.csdn.net/gatieme/article/details/51251311)

## 题目描述
```text
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
如果不存在则输出0
```

## 样例
### 输入
```text
1 2 3 2 2 2 5 4 2
```

### 输出
```text
2
```

## 思路
### 方法一： 排序以后统计个数
如果是排序好的数组，那么我们就很容易统计每个数组出现的次数，而题目中并没有说数组是排序好的，
因此我们需要先排序（最好的情况下O(nlogn)），
后统计（一次遍历即可O(n)）,因此这种方法的时间复杂度为O(nlogn)

### 方法二： 基于Partition函数的O(n)的查找第K大的数
上面基于排序的算法比较保守，因为它没有充分利用出现次数超过一半这个条件。

数组中有一个数字出现的次数超过了数组长度的一半，那么如果我们把这个数组排序，那么排序之后位于数组中间的那个数字一定就是那个出现次数超过数组长度一半的数字

也就是说这个数字其实就是统计学上的中位数，即长度为N的数组中的N/2大的元素，因此我们的题目最后成为返回数组中第K（K=Len/2）大的数。

因此我们的问题成为查找一个数组中的K大的元素

我们写过快速排序算法，其中的Partition()方法是一个最重要的方法，该方法返回一个index，能够保证index位置的数是已排序完成的，在index左边的数都比index所在的数小，在index右边的数都比index所在的数大。那么本题就可以利用这样的思路来解。

### 方法三：阵地攻守（特点–它出现的次数比其他所有的数组出现的次数之和还要多）

采用阵地攻守的思想
- 第一个数字作为第一个士兵，守阵地；count = 1；
- 遇到相同元素，count++; 遇到不相同元素，即为敌人，同归于尽,count–；
- 当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。
- 再加一次循环，记录这个士兵的个数看是否大于数组一般即可。

### 方法三： 使用map来建立数字到出现次数的映射
我们可以使用一个map来建立数字-=>出现次数的一个映射，这样最后遍历找到出现次数大于数组长度一半的那个元素即可




