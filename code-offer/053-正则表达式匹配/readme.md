[toc]

## 题目
- [题目](https://blog.csdn.net/gatieme/article/details/51542072)
- [题目二](https://leetcode-cn.com/problems/regular-expression-matching/)

## 题目描述
```text
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:
    s 可能为空，且只包含从 a-z 的小写字母。
    p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

```

## 示例
### 示例 1:
```text
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

### 示例 2:
```text
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```
## 思路
### 方法一： 分治–类似与深度优先搜索DFS
我们会分治搜索的方法来查看，
- 考虑特殊情况即*s字符串或者*p字符串结束。
    1. s字符串结束，要求*p也结束或者间隔‘’ （例如p=”a*b*c……”），否则无法匹配
    2. *s字符串未结束，而*p字符串结束，则无法匹配

- *s字符串与*p字符串均未结束
    1. (p+1)字符不为’‘，则只需比较s字符与p字符，若相等则递归到(s+1)字符串与(p+1)字符串的比较，否则无法匹配。
    2. (p+1)字符为’‘，则p字符可以匹配s字符串中从0开始任意多（记为i）等于*p的字符，然后递归到(s+i+1)字符串与(p+2)字符串的比较，

只要匹配一种情况就算完全匹配。

### 方法二： 动态规划
dp[i][j] 表示 s[0..i] 和 p[0..j] 是否 match，

当 p[j] != ‘*’，b[i + 1][j + 1] = b[i][j] && s[i] == p[j] ，

当 p[j] == ‘*’ 要再分类讨论，具体可以参考 DP C++，还可以压缩下把 dp 降成一维：

## 参考
- [leetcode](https://github.com/aQuaYi/LeetCode-in-Go/blob/master/Algorithms/0010.regular-expression-matching/regular-expression-matching.go)